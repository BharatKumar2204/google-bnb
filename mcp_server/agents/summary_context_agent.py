"""
Agent 3: Summary & Context Agent
Summarizes and contextualizes news using Gemini AI
"""

import logging
from typing import Dict, List
import google.generativeai as genai

logger = logging.getLogger(__name__)

class SummaryContextAgent:
    def __init__(self, config, gcp_clients):
        self.config = config
        self.gcp_clients = gcp_clients
        self.logger = logging.getLogger("agent.summary")
        
        # Initialize Gemini AI
        self.use_ai = False
        if hasattr(config, 'GEMINI_API_KEY') and config.GEMINI_API_KEY:
            try:
                api_key = config.GEMINI_API_KEY.strip('"').strip("'")
                genai.configure(api_key=api_key)
                self.model = genai.GenerativeModel('gemini-2.5-pro')
                self.use_ai = True
                self.logger.info("âœ… Gemini 2.5 Pro enabled for summarization")
            except Exception as e:
                self.logger.warning(f"âš ï¸ Gemini AI not available: {str(e)}")
        
    async def execute(self, payload: Dict) -> Dict:
        """Summarize and contextualize text"""
        try:
            text = payload.get("text", "")
            title = payload.get("title", "Article")
            
            # Use AI if available
            if self.use_ai and len(text) > 50:
                self.logger.info("ğŸ¤– Using AI-powered summarization")
                ai_result = await self._ai_summarize(text, title)
                if ai_result:
                    return {
                        **ai_result,
                        "title": title,
                        "word_count": len(text.split()),
                        "method": "ai_powered"
                    }
            
            # Fallback to basic summarization
            self.logger.info("ğŸ“Š Using basic summarization")
            summary = self._generate_summary(text)
            key_points = self._extract_key_points(text)
            context = self._add_context(text)
            
            return {
                "summary": summary,
                "key_points": key_points,
                "context": context,
                "title": title,
                "word_count": len(text.split()),
                "method": "rule_based"
            }
            
        except Exception as e:
            self.logger.error(f"Error: {str(e)}")
            return {"error": str(e)}
    
    async def _ai_summarize(self, text: str, title: str) -> Dict:
        """Use Gemini AI for intelligent summarization"""
        prompt = f"""Analyze this news article and provide:

1. A concise 2-3 sentence summary
2. 3-5 key points (bullet points)
3. Main topics covered
4. Overall sentiment (Positive/Negative/Neutral)
5. Complexity level (Simple/Medium/Complex)

Article Title: {title}
Article Text: {text[:2000]}

Respond in this exact format:
SUMMARY: [your summary here]
KEY_POINTS:
- [point 1]
- [point 2]
- [point 3]
TOPICS: [comma-separated topics]
SENTIMENT: [sentiment]
COMPLEXITY: [complexity]
"""
        
        response = self.model.generate_content(prompt)
        result_text = response.text
        
        # Parse AI response
        summary = ""
        key_points = []
        topics = []
        sentiment = "Neutral"
        complexity = "Medium"
        
        lines = result_text.split('\n')
        current_section = None
        
        for line in lines:
            line = line.strip()
            if line.startswith('SUMMARY:'):
                summary = line.split(':', 1)[1].strip()
                current_section = None
            elif line.startswith('KEY_POINTS:'):
                current_section = 'points'
            elif line.startswith('TOPICS:'):
                topics = [t.strip() for t in line.split(':', 1)[1].split(',')]
                current_section = None
            elif line.startswith('SENTIMENT:'):
                sentiment = line.split(':', 1)[1].strip()
                current_section = None
            elif line.startswith('COMPLEXITY:'):
                complexity = line.split(':', 1)[1].strip()
                current_section = None
            elif current_section == 'points' and line.startswith('-'):
                key_points.append(line[1:].strip())
        
        self.logger.info(f"âœ… AI Summary generated: {len(key_points)} key points")
        
        return {
            "summary": summary or "Summary generated by AI",
            "key_points": key_points or ["Analysis complete"],
            "context": {
                "topics": topics or ["General"],
                "sentiment": sentiment,
                "complexity": complexity
            }
        }
    
    def _generate_summary(self, text: str) -> str:
        """Generate summary (simplified)"""
        sentences = text.split('.')
        # Take first 3 sentences as summary
        summary_sentences = sentences[:3]
        return '. '.join(s.strip() for s in summary_sentences if s.strip()) + '.'
    
    def _extract_key_points(self, text: str) -> List[str]:
        """Extract key points"""
        key_points = []
        sentences = text.split('.')
        
        # Look for important sentences
        keywords = ['important', 'significant', 'major', 'key', 'critical', 'announced', 'revealed']
        
        for sentence in sentences[:10]:  # Check first 10 sentences
            sentence = sentence.strip()
            if any(keyword in sentence.lower() for keyword in keywords):
                if len(sentence) > 20:
                    key_points.append(sentence)
        
        # If no key points found, use first few sentences
        if not key_points:
            key_points = [s.strip() for s in sentences[:3] if len(s.strip()) > 20]
        
        return key_points[:5]  # Return max 5 points
    
    def _add_context(self, text: str) -> Dict:
        """Add contextual information"""
        text_lower = text.lower()
        
        topics = []
        topic_keywords = {
            "Technology": ["ai", "tech", "software", "computer", "digital"],
            "Politics": ["government", "election", "policy", "political"],
            "Health": ["health", "medical", "disease", "hospital", "doctor"],
            "Business": ["business", "economy", "market", "company", "financial"],
            "Science": ["science", "research", "study", "discovery"],
            "Environment": ["climate", "environment", "pollution", "green"]
        }
        
        for topic, keywords in topic_keywords.items():
            if any(keyword in text_lower for keyword in keywords):
                topics.append(topic)
        
        return {
            "topics": topics or ["General"],
            "sentiment": self._analyze_sentiment(text),
            "complexity": "Medium" if len(text.split()) > 200 else "Low"
        }
    
    def _analyze_sentiment(self, text: str) -> str:
        """Simple sentiment analysis"""
        text_lower = text.lower()
        
        positive_words = ["good", "great", "success", "positive", "improvement", "growth"]
        negative_words = ["bad", "crisis", "problem", "concern", "decline", "threat"]
        
        pos_count = sum(1 for word in positive_words if word in text_lower)
        neg_count = sum(1 for word in negative_words if word in text_lower)
        
        if pos_count > neg_count:
            return "Positive"
        elif neg_count > pos_count:
            return "Negative"
        else:
            return "Neutral"
